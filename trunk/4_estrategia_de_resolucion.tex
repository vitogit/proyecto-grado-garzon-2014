\chapter{Estrategia de resolución}

En este capitulo se presenta el algoritmo desarrollado, su estructura, parámetros y configuración. 

\section{Libreria Malva}

Malva [http://themalvaproject.github.io/] surge como una variante del proyecto Mallba [http://neo.lcc.uma.es/mallba/easy-mallba/index.html ] . Propone la actualización, mejora y desarrollarlo como un proyecto de código abierto colaborativo.  Su objetivo es proveer de varios esqueletos de heuristicas de optimización que puedan ser utilizados y extendidos de manera fácil y eficiente.

Los esqueletos se basan en separar dos conceptos: El problema concreto que se quiere resolver y por otro lado el método utilizado para resolverlo. Por tanto un esqueleto se puede ver como un template genérico que se instancia para resolver un problema particular, manteniendo todas las funcionalidades genéricas.

Utiliza el lenguaje c++ dado su alto nivel, modularidad y flexibilidad. Los esqueletos se ofrecen como un conjunto de clases requeridas que son las que el usuario deberá modificar para adaptarlo a su problema y las provistas. que incluyen todos los aspectos internos del esqueleto y on independientes del problema particular.
Los esqueletos provistos o sea los algoritmos soportados son Algoritmos genéticos y CHC[].


\newpage

\section{Especificación del Algoritmo Genético utilizado}
Se utiliza el el algoritmo genético proviso por la librería  Malva  llamado NewGA.
Entre sus características se encuentra que tiene la posibilidad de reemplazar padres por hijos, la selección de los padres se realiza por torneo de 3 individuos, y la selección de hijos por ruleta.

Mas adelante se realizara un ajuste de parámetros para determinar la población, factor de mutación y de cruzamiento usados por el algoritmo.

El siguiente esquema muestra el algoritmo utilizado. \citep{MalvaAlgGenetico}

 
\begin{algorithm}[H]
	\caption{Algoritmo Genético de Malva}
	\label{alg:algoritmo_genetico_malva}
	\begin{algorithmic} [1] 
		{
			\STATE \texttt{t} = 0
			\STATE {Inicializo( P(t))}
			\STATE {Evaluar estructuras en ( P(t))}			
			\WHILE {\text{No termine}}
			\STATE \texttt{t}++		
			\STATE {Seleccionar C(t) de P(t-1)}	
			\STATE {Recombinar estructuras en C(t) formando C'(t)}				
			\STATE {Mutar estructuras en C'(t) formando C''(t)}		
			\STATE {Evaluar estructuras en C''(t)}					
			\STATE {Reemplazar P(t) de C''(t) y P(t-1)}								
			\ENDWHILE
		}
	\end{algorithmic}

\end{algorithm}


 

\subsection{Representación}
Para poder explicar la representación del problema de los
semáforos del corredor Garzón, es preciso compartir algunas
definiciones que usaremos a lo largo de la propuesta:
Cruce: se define como el lugar de intersección de dos o
más vías de circulación.
Fase: es la configuración de las luces de los semáforos
en un determinado cruce; un cruce tiene hasta 8 fases.
Por ejemplo una fase de un cruce puede ser
“rrrrGGrrrrGG” durante 52 segundos. Donde “G” es
Verde, “r” es Rojo y “y” es Amarillo.  
Es  importante  que  el  algoritmo  evolutivo  a  implementar  no
genere soluciones que no sean viables por lo que éste no debe
de poder modificar la combinación de luces de cada fase y de

esta manera no se generarán fases con combinaciones de luces
equivocadas (podría generar accidentes de tránsito).
En  pos  de  un  mejor  rendimiento  y  ya  que  en  realidad  no
modifican  los  tiempos  reales  del  paso  de  los  vehículos,  se
omitieron  las   fases  que  tienen  luces  amarillas  en  la
representación del cromosoma.
El  cromosoma  se  va  a  agrupar  lógicamente  en  cruces,
definimos el valor de un gen como el tiempo que demora una
fases  de  un  cruce  (sin  considerar  las  amarilla,  estas  quedan
fijas con el valor obtenido en la realidad) o la fase con la que
inicia un cruce, por lo que el tamaño del cromosoma depende
de  la  cantidad  de  cruces  y  de  la  cantidad  de  fases  que  tiene
cada cruce, teniendo así la información de todos los cruces.

\subsection{Codificación} 
A continuación se muestra un ejemplo en el cual se mapea un
cruce representado en el cromosoma y un cruce representado
en  el  archivo  de  configuración  de  semáforos  que  utiliza  el
simulador SUMO.
Como se  mencionó anteriormente se omite el valor de la luz
amarilla en el cromosoma y se mantiene el valor real recabado
y el valor que tiene el cromosoma en el gen de inicio de fase
se corresponde con el valor de “offset” en el XML.
Cruce representado en el cromosoma:

\subsection{Inicialización}
Para la inicialización de la población se toma como referente
la configuración obtenida con los datos in situ, luego para cada
cruce  se  hacen  variar  las  duraciones  de  las  fases  de  manera
aleatoria  entre  un  rango  de  5  segundos  a  60  segundos  (estos
valores  son  configurables)  y  la  fase  inicial  se  hace  variar
aleatoriamente entre la cantidad de fases del cruce  (se cuentan
las luces amarillas).

\subsection{Función fitness}
Para evaluar un individuo, lo que se hace es crear un archivo
XML  de configuración de señalización de tránsito que utiliza
el  simulador  SUMO  en  base  al  cromosoma  del  individuo,
luego se ejecuta el simulador con la configuración generada, el
tiempo de simulación devuelto será el valor de la función de
fitness.

\subsection{Operadores}
\subsubsection{Selección}
\subsubsection{Cruzamiento}
Se  utilizará  cruzamiento  de  un  punto  (1PX),  implementado
específicamente  para  el  problema,  seleccionando  el  intervalo
entre 2 cruces como punto de corte, por ejemplo:
Esto  hace  que  si  un  tramo  del  corredor  es  bueno,  esta
propiedad se mantenga.

\subsubsection{Mutación}
La  mutación también fue  implementada  específicamente para
el problema, utilizaremos dos tipos de mutación:
Mutación de duración de fase: para cada fase de cada cruce se
hace variar su duración sumando o restando una cantidad dada
de segundos entre un rango determinado con una probabilidad
dada.
Mutación de inicio de cruce: se elige aleatoriamente una fase
con  la  cual  va  a  arrancar  inicialmente  el  cruce  con  una
probabilidad dada.

\subsection{Criterio de parada}
 Cantidad  de  generaciones:  Es  la  cantidad  de
 generaciones  con  la  cual  se  toma  el  criterio  de  parar  la
 ejecución del algoritmo, el número de generaciones que vamos
 a usar es x
 Probabilidad  de  convergencia:  La  convergencia  se
 define como la relación entre los N mejores valores de fitness
 de  las  generaciones  anteriores  contra  el  mejor  valor  de  la
 generación actual. Nosotros vamos a utilizar N con el valor de
 x y una probabilidad de convergencia de x




\section{Multiobjetivo}

\section{Algoritmo Paralelo}
Agregar diagrama de maestro esclavo



\section{Resumen}